name: Workloads continuous integration, delivery and deployment
run-name: "${{ github.actor }} triggered global workload CI/CD"

on:
    push:
        branches: 
             - main
             - release
        tags:
            - v[0-9]+.[0-9]+.[0-9]+
        paths: 
            - frontend/**
            - backend/**
    # workflow_dispatch: # TODO : integrate the production logic inside this workflow. (too many if ? )
    # What can be done with workflow_run event ? 


    #TODO: we miss the next version bump definition. 

    

jobs:
    get_env:
        runs-on: ubuntu-22.04
        outputs:
            environment: ${{ steps.get_env.outputs.environment }}
        steps:
            - name: guess environment
              id: get_env
              uses: actions/get_workload_flow_env@v1

    # TODO: documenter dans le README pk la CI n'est pas souhaitable pour des contextes où l'output est une image docker agnostique de l'env, alors qu'elle l'est sur la partie infra (config et couts différents par env, )
    frontend_integration:
        if: contains(fromJSON('["integration"]'), needs.get_env.outputs.environment)
        needs: get_env
        permissions: 
            pull-requests: 
                write
        uses: ./.github/workflows/frontend_integration.yaml


    backend_integration:
        if: contains(fromJSON('["integration"]'), needs.get_env.outputs.environment)
        needs: get_env
        uses: ./.github/workflows/backend_integration.yaml


    container_integration:
        if: contains(fromJSON('["integration"]'), needs.get_env.outputs.environment)
        needs: get_env
        uses: ./.github/workflows/container_integration.yaml

    collect_env_variables_of_interest:
        if: github.event_name != 'workflow_dispatch'
        needs: get_env
        runs-on: ubuntu-22.04
        environment:
            name: ${{ needs.get_env.outputs.environment }}
        outputs:
            project_id: ${{ steps.get_env_var.outputs.project_id }}
            repository_id: ${{ steps.get_env_var.outputs.repository_id }}
            workload_identity_provider: ${{ steps.get_env_var.outputs.workload_identity_provider }}
            service_account_to_impersonate: ${{ steps.get_env_var.outputs.service_account_to_impersonate }}
            region: ${{ steps.get_env_var.outputs.region }}
        steps:
            - name: get env vars
              id: get_env_var
              uses: actions/get_workload_flow_env@v1

        
    container_delivery:
        needs: [collect_env_variables_of_interest, backend_integration, frontend_integration, container_integration]
        uses: ./.github/workflows/container_delivery.yaml
        # environment: --> cannot be used in a job calling a subworkflow. Needs the 'collect_env_variables_of_interest' job to collect env values and inject it below
        with:
            files: |           
                ./frontend/**
                ./backend/**
            files_ignore: |
                **/*.md
            project_id: ${{ needs.collect_env_variables_of_interest.outputs.project_id }}
            repository_id: ${{ needs.collect_env_variables_of_interest.outputs.repository_id }} 
            workload_identity_provider: ${{ needs.collect_env_variables_of_interest.outputs.workload_identity_provider }}
            service_account_to_impersonate: ${{ needs.collect_env_variables_of_interest.outputs.service_account_to_impersonate }}
            region: ${{ needs.collect_env_variables_of_interest.outputs.region }}

    # TODO: to complete. Set as input the environment. if env is production, the triggering event is to be a workflow dispatch.
    # Otherwise, push. And if production, the dispatch must be done on a tag abiding by the pattern: vx.y.z 
    workloads_deployment:  #TODO: check also that the dispatch is done on a comitish of form vx.y.z
        if: github.ref_name == 'main' || github.ref_name == 'release'
        needs: [container_delivery, get_env]
        uses: ./.github/workflows/workloads_deployment.yaml
        with:
            environment: ${{ needs.get_env.outputs.environment }}

    # TODO: final job : push the badge status. This task should always run even in case of previous task failure