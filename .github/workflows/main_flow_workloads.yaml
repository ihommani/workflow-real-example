name: Workloads continuous integration, delivery and deployment
run-name: "${{ github.actor }} triggered global workload CI/CD"

on:
    push: # this logic is part of our git workflow
        branches: 
             - main
             - release
        tags:
            - v*.*.*
        paths: 
            - frontend/**
            - backend/**
    # workflow_dispatch: # TODO : integrate the production logic inside this workflow. (too many if ? )
    # What can be done with workflow_run event ? 
    workflow_dispatch: 
        inputs:
            environemnt:
                description: On what environment to deploy the targeted version
                options:
                    - integration
                    - staging
                    - production
                type: choice
                required: true
                default: staging
    

jobs:

    get_env:
        runs-on: ubuntu-22.04
        outputs:
            environment: ${{ steps.get_env.outputs.environment }}
        steps:
            - name: guess environment
              id: get_env
              uses: actions/get_workload_flow_env@v1

    # TODO: documenter dans le README pk la CI n'est pas souhaitable pour des contextes où l'output est une image docker agnostique de l'env, alors qu'elle l'est sur la partie infra (config et couts différents par env, )
    frontend_ci:
        if: github.event_name != 'workflow_dispatch' && contains(fromJSON('["integration"]'), needs.get_env.outputs.environment)
        needs: get_env
        permissions: 
            pull-requests: 
                write
        uses: ./.github/workflows/frontend_ci.yaml


    backend_integration:
        if: github.event_name != 'workflow_dispatch' && contains(fromJSON('["integration"]'), needs.get_env.outputs.environment)
        needs: get_env
        uses: ./.github/workflows/backend_integration.yaml


    container_integration:
        if: github.event_name != 'workflow_dispatch' && contains(fromJSON('["integration"]'), needs.get_env.outputs.environment)
        needs: get_env
        uses: ./.github/workflows/container_integration.yaml

    # See comment on 'container_cd' job to understand why we need this taskcontainer_cd
    collect_env_variables_of_interest:
        if: github.event_name != 'workflow_dispatch'
        needs: get_env
        runs-on: ubuntu-22.04
        environment:
            name: ${{ needs.get_env.outputs.environment }}
        outputs:
            project_id: ${{ steps.get_env_var.outputs.project_id }}
            repository_id: ${{ steps.get_env_var.outputs.repository_id }}
            workload_identity_provider: ${{ steps.get_env_var.outputs.workload_identity_provider }}
            service_account_to_impersonate: ${{ steps.get_env_var.outputs.service_account_to_impersonate }}
            region: ${{ steps.get_env_var.outputs.region }}
        steps:
            - name: get env vars
              id: get_env_var
              uses: actions/get_workload_flow_env@v1

        
    container_delivery:
        if: github.event_name != 'workflow_dispatch'
        needs: [collect_env_variables_of_interest, backend_integration, frontend_ci, container_integration]
        uses: ./.github/workflows/container_delivery.yaml
        # environment: --> cannot be used in a job calling a subworkflow. Needs the 'collect_env_variables_of_interest' job to collect env values and inject it below
        with:
            files: |           
                ./frontend/**
                ./backend/**
            files_ignore: |
                **/*.md
            project_id: ${{ needs.collect_env_variables_of_interest.outputs.project_id }}
            repository_id: ${{ needs.collect_env_variables_of_interest.outputs.repository_id }} 
            workload_identity_provider: ${{ needs.collect_env_variables_of_interest.outputs.workload_identity_provider }}
            service_account_to_impersonate: ${{ needs.collect_env_variables_of_interest.outputs.service_account_to_impersonate }}
            region: ${{ needs.collect_env_variables_of_interest.outputs.region }}

    # TODO: to complete. Set as input the environment. if env is production, the triggering event is to be a workflow dispatch.
    # Otherwise, push. And if production, the dispatch must be done on a tag abiding by the pattern: vx.y.z 
    workloads_deployment:
        if: github.ref_name == 'main' || github.ref_name == 'release' || (github.event_name == 'workflow_dispatch') #TODO: check also that the dispatch is done on a comitish of form vx.y.z
        needs: [container_delivery, get_env]
        uses: ./.github/workflows/workloads_deployment.yaml
        with:
            environment: ${{ needs.get_env.outputs.environment }}

    # TODO: final job : push the badge status. This task should always run even in case of previous task failure