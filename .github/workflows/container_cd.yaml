name: Containers continuous delivery
run-name: '${{ github.actor }} triggers containers continuous delivery'

on:
    workflow_call:
      inputs:
        files:
          description: File and directory patterns used to detect changes. Defaults to the entire repo if unset
          required: true
          type: string
        files_ignore:
          description: Ignore changes to these file(s)
          required: false
          type: string 
          default: ''
        project_id:
          description: Location of the consumed resources
          required: true
          type: string
        repository_id:
          description: Image repository id
          required: true
          type: string
        workload_identity_provider:
          description: |-
            Identifier of the concrete workload identity provider. 
          required: true
          type: string
        service_account_to_impersonate:
          description: |-
            Identity to impersonate through the workload identity provider
          required: true
          type: string
        region:
          description: |-
            Region of the concrete artifactory service
          required: true
          type: string

jobs:
    check_sources_change:
      uses: ./.github/workflows/_check_source_changes.yaml
      with:
        files: ${{ inputs.files }}
        files_ignore: ${{ inputs.files_ignore }}
        get_folders : true


    get_docker_files:
      runs-on: ubuntu-22.04
      outputs:
        docker_files: ${{ steps.docker_files_list.outputs.docker_files }}

      steps:

        - name: Checkout sources
          id: checkout_sources
          uses: actions/checkout@v4

        - name: Get Docker files from sources
          id: get_docker_files
          uses: tj-actions/glob@v22
          with:
            separator: ','
            files: |
              **/Dockerfile*

        - name: Render Docker files list Json compatible
          id: docker_files_list
          run: |
            echo "docker_files=[$(echo ${{ steps.get_docker_files.outputs.paths }} | sed 's/[^,][^,]*/"&"/g')]" >> $GITHUB_OUTPUT


    build_status_per_dockerfile:
      runs-on: ubuntu-22.04
      needs: [check_sources_change, get_docker_files]
      if: needs.check_sources_change.outputs.is_modified_files == 'true'

      strategy:
        fail-fast: false
        matrix:
          docker_file_path: ${{ fromJson(needs.get_docker_files.outputs.docker_files) }}

      steps:
        - name: Get Dockerfile dirname
          id: get_docker_file_dirname
          run: |-
            echo "$(dirname ${{ matrix.docker_file_path }})"
            echo "dirname=$(dirname ${{ matrix.docker_file_path }})" >> $GITHUB_OUTPUT

          # TODO: does not work with subfolder to Dockerfile dirname. To adapt.
        - name: Compute rebuild status per Dockerfile. True if sources in Dockerfile dirname changed.
          id: compute_image_to_build_status
          run: |-
             echo '${{ needs.check_sources_change.outputs.all_changed_files }}'
             echo "to_build=$(echo '${{ needs.check_sources_change.outputs.all_changed_files }}' | jq  '. | index("${{ steps.get_docker_file_dirname.outputs.dirname }}")')" >> $GITHUB_OUTPUT

        - name: Tagging Docker file to rebuild
          id: is_image_to_build
          run: echo "image_to_build=${{ !startsWith('null', steps.compute_image_to_build_status.outputs.to_build) }}" >> $GITHUB_OUTPUT

        ## Write for matrix outputs workaround 
        # https://github.com/marketplace/actions/matrix-outputs-write
        # https://github.com/orgs/community/discussions/17245
        - uses: cloudposse/github-action-matrix-outputs-write@v1
          id: out
          with:
            matrix-step-name: ${{ github.job }}
            matrix-key: ${{ matrix.docker_file_path }}
            outputs: |-
              to_build: ${{ steps.is_image_to_build.outputs.image_to_build }}


    matrix_read:
      runs-on: ubuntu-latest
      needs: [build_status_per_dockerfile]

      outputs:
        result: "${{ steps.matrix_read.outputs.result }}"

      steps:
        - name: Read matrix output
          id: matrix_read
          uses: cloudposse/github-action-matrix-outputs-read@v1
          with:
            matrix-step-name: build_status_per_dockerfile
        - run: echo "${{ steps.matrix_read.outputs.result }}"


    build_push_image:
      runs-on: ubuntu-22.04
      needs: [get_docker_files, build_status_per_dockerfile, matrix_read]
      permissions: 
        contents: 'read'
        id-token: 'write'
      strategy:
        # TODO: document in the README
        # If one of the OCI image build fails, then no images push should happens. 
        # This is not bullet proof as, one of the matrix path can still passes before a path failure
        # Tagging image, even if not rebuilt, with the triggering event sha1 allows to relaunch the workflow to allign the service images on a common sha1.
        fail-fast: true 
        matrix:
          docker_file_path: ${{ fromJson(needs.get_docker_files.outputs.docker_files) }}

      steps:
        - name: Checkout sources
          uses: actions/checkout@v4

        - name: Authenticate to gcp workload identity pool
          id: auth_to_google
          uses: 'google-github-actions/auth@v2'
          with:
              workload_identity_provider: ${{ inputs.workload_identity_provider }}
              service_account: ${{ inputs.service_account_to_impersonate }}
              token_format: access_token
              access_token_lifetime: 300s
              create_credentials_file: true

        - name: Filter Dockerfile to_build status
          id: is_image_to_build_status
          run: echo "to_build=$(echo '${{ needs.matrix_read.outputs.result }}' | jq '.to_build."${{ matrix.docker_file_path }}"')" >> $GITHUB_OUTPUT

        - name: Compute image name
          id: infer-image-name
          shell: bash
          run: |
            path=${{ matrix.docker_file_path }}
            image_name=${path##*Dockerfile}
            default=_$(basename $(dirname ${{ matrix.docker_file_path }})) # if image name is empty put the folder name containing Dockerfile as image name. Note the leading '_'
            tmp_name=${image_name:-$default}
            final_name=${tmp_name:1:100} # We remove the leading '_' and take the rest
            echo "image_name=$final_name" >> $GITHUB_OUTPUT

        - name: Image delivery
          if: ${{ contains('true', steps.is_image_to_build_status.outputs.to_build) }}
          id: image_delivery
          uses: ./.github/actions/docker_build_push
          with:
            dockerfile_path: ${{ matrix.docker_file_path }}
            image_tag: ${{ inputs.region }}-docker.pkg.dev/${{ inputs.project_id }}/${{ inputs.repository_id }}/${{ steps.infer-image-name.outputs.image_name }}:${{ github.sha }}
            registry_id: ${{ inputs.region }}-docker.pkg.dev
            access_token: ${{ steps.auth_to_google.outputs.access_token }}

        - name: Image tagging
          id: image_tagging
          uses: ./.github/actions/image_tag
          with:
            workload_identity_provider: ${{ inputs.workload_identity_provider }}
            service_account_to_impersonate: ${{ inputs.service_account_to_impersonate }}
            image_name: ${{ inputs.region }}-docker.pkg.dev/${{ inputs.project_id }}/${{ inputs.repository_id }}/${{ steps.infer-image-name.outputs.image_name }}
